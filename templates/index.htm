<html>

<head>
  <title>HW2: INFO 4310</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <style>
    /* General CSS ------------------------------*/
    .outline {
      fill: none;
      stroke: black;
    }

    .filter_label {
      margin: 0em;
    }

    .mouseover {
      pointer-events: none;
    }

    .country {
      fill: rgb(92, 91, 91);
    }

    body {
      padding: 2em 2em;
      margin: auto;
      background-color: rgb(42, 37, 37);
      color: white;
      font-family: Helvetica
    }

    table {
      color: white;
      border-collapse: collapse;
    }

    th,
    td {
      border-top: 2px solid white;
      border-bottom: 2px solid #ddd;
      padding: 10px;
    }

    #panel {
      height: 400px;
      width: 300px;
      float: left;
      padding: 20 30 20 20;
    }

    .filter_label {
      font-weight: bold;
    }

    .volcano_button {
      background-color: white;
      color: black;
      border-radius: 5px;
      border: none;
      padding: 5px 7px;
      margin: 5px 5px 0px 0px;
      border: 3px solid white
    }

    .volcano_button:hover {
      background-color: rgb(72, 17, 17);
      color: white;
    }

    .selected-volcano-type {
      background-color: rgb(72, 17, 17);
      border: 3px solid white;
      color: white;
      border-radius: 5px;
      padding: 5px 7px;
      margin: 5px 5px 0px 0px;
    }

    /* slider styles ------------------------------ */

    .left_panel {
      border-right: 2px solid white;
      height: 660px;
      float: left;
      padding-right: 2em;
      margin-right: 1em;
      width: 250px;
      ;
    }

    .slider-ticks {
      font: 14px sans-serif;
    }

    .background,
    .background-inset,
    .background-overlay {
      stroke-linecap: round;
    }

    .background {
      stroke: #333232;
      stroke-width: 10px;
    }

    .background-overlay {
      pointer-events: stroke;
      stroke-width: 50px;
    }

    .selected {
      stroke: #9e0b00;
      stroke-width: 8px;
    }

    .knob {
      fill: #E0F7FA;
      stroke: #000;
      stroke-opacity: 0.5;
      stroke-width: 1.25px;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div>

    <h1 style="font-size: 36pt;">Volcanic Eruptions </h1>
    <div class="left_panel">
      <h2 style="margin-top: 0px;">Filters</h2>
    </div>
    <svg id="worldMap" height="600" width="775"
      style="background-color: rgb(42, 37, 37); margin-top: 20px; float:left; margin-bottom: 2em;"></svg>

    <div id="panel">
    </div>

    <script>
      const drawMap = async () => {

        // geojson
        const world = await d3.json(".././static/world-data.json");

        // countries
        const countries = topojson.feature(world, world.objects.countries);

        // mesh
        const countriesMesh = topojson.mesh(world, world.objects.countries);

        // load volcano data
        let volcanoes = await d3.csv(".././static/volcanoes_filtered4.csv");
        console.log(volcanoes);

        let volcanoCountries = new Set(volcanoes.map(d => d.country));
        console.log(volcanoCountries);

        // mapSvg
        let map = d3.select("svg#worldMap");

        // width/height
        let mapWidth = map.attr("width");
        let mapHeight = map.attr("height");

        // map projection
        let projection = d3
          .geoMercator()
          .fitSize([mapWidth, mapHeight], countries);

        // path
        let path = d3.geoPath().projection(projection);

        // map viewport for zoom/pan
        let viewport = map.append("g");

        // draw countries
        viewport
          .selectAll("path.country")
          .data(countries.features)
          .join("path")
          .attr("class", "country")
          .attr("d", path)
          .on("mouseover", mouseEntersCountry)
          .on("mouseout", mouseLeavesCountry)
          .on("click", clickCountry);

        // COUNTRY MESH
        viewport
          .append("path")
          .datum(countriesMesh)
          .attr("class", "outline")
          .style("stroke", "grey")
          .style("stroke-width", 1)
          .style("fill", "none")
          .attr("d", path)

        // outline mesh
        let countryOutline = map
          .append("path")
          .attr("class", "mouseover outline")
          .style("stroke", "white")
          .style("stroke-width", 2)
          .attr("d", "");

        // set used to keep track of countries selected
        let clicked = new Set();

        // used to scale outlines and volcano circles with zoom
        let logTransformK = 1;
        let transformK = 1;

        // adds country outline
        function mouseEntersCountry() {
          let country = d3.select(this);
          let countryName = country.datum().properties.name;

          if (!clicked.has(countryName) && volcanoCountries.has(countryName)) {
            if (clicked.size < 3) {
              drawOutline(countryName);
            }
          }
        }

        // updates radar by adding country data
        // removes country data if country is already selected
        // does nothing if 3 countries are already selected
        function clickCountry() {
          let country = d3.select(this);
          let countryName = country.datum().properties.name;

          if (!clicked.has(countryName) && volcanoCountries.has(countryName)) {
            if (clicked.size < 3) {
              clicked.add(countryName); // adding country name to clicked
              filters.country.push(countryName)
              drawOutline(countryName);
              updateSpiderGraph();
              updateWorldMap()
            }
          }
          else {
            countryOutline.attr("d", ""); //removing outline
            clicked.delete(countryName)
            filters.country = filters.country.filter(d => d != countryName)
            updateWorldMap()
            updateSpiderGraph();
          }

        }

        // Removes country outline
        function mouseLeavesCountry() {
          let country = d3.select(this);
          let countryName = country.datum().properties.name;

          //check if something is not clicked
          if (!clicked.has(countryName) && volcanoCountries.has(countryName)) {
            removeOutline(countryName);
          } else {
            return;
          }
        }

        // outlines country mouse is over
        function drawOutline(countryName) {
          let countryOutline = topojson.mesh(
            world,
            world.objects.countries,
            (a, b) => a.properties.name === countryName || b.properties.name === countryName
          );

          if (countryName !== undefined || volcanoes.country) {
            let name = 'outline-' + countryName.replace(/\s+/g, '-').replace(/[^a-zA-Z-_]/g, '');

            let outline = viewport.select('.' + name);
            if (outline.empty()) {
              outline = viewport
                .append("path")
                .attr("class", "mouseover outline " + name);
            }

            outline
              .datum(countryOutline)
              .attr("d", path)
              .style("stroke", "white")
              .style("stroke-width", 2 / transformK);
          }
        }

        // removes outline
        function removeOutline(countryName) {
          map.select('.outline-' + countryName.replace(/\s+/g, '-').replace(/[^a-zA-Z-_]/g, '')).remove();
        }

        // TODO finish
        // create threshold scale for coloring volcanoes
        let thresholds = [2, 5, 10, 50, 100, 150, 200]
        const eruptionColorScale = d3.scaleThreshold([2, 5, 10, 50, 100, 150], d3.schemeYlOrRd[8])
        // const eruptionColorScale = d3.scaleQuantize(d3.extent(volcanoes, d=>d.num_eruptions), d3.schemeYlOrRd[7])

        // legend
        const legend = map.append("g")

        // size of each coloreds rectangle
        const legendSize = 25

        // distance between rect
        const spacing = 10

        // add title
        legend.append("text").text("Number of Eruptions")
          .attr("x", mapWidth - (legendSize + spacing) * 8)
          .attr("y", 20)
          .attr("fill", "white")
          .attr("class", "legend-title")

        // add rectangles
        legend.selectAll("rect").data(thresholds)
          .join("rect")
          .attr("x", (d, i) => mapWidth - (legendSize + spacing) * 8 + i * (legendSize + spacing))
          .attr("y", 30)
          .attr("width", legendSize)
          .attr("height", legendSize)
          .attr("class", "rect-legend")
          .attr("fill", d => eruptionColorScale(d))

        // add labels
        legend.selectAll("text.legend-label").data(thresholds)
          .join("text")
          .attr("x", (d, i) => mapWidth - (legendSize + spacing) * 8 + i * (legendSize + spacing))
          .attr("class", "legend-label")
          .attr("y", 70)
          .attr("fill", "white")
          .attr("style", "font-size:10pt")
          .text(d => `<${d}`)

        // modify data types to numbers and add show tag
        volcanoes.forEach(d => {
          d.Position = projection([d.longitude, d.latitude]);
          d.num_eruptions = +d.num_eruptions
          d.elevation = +d.elevation

          // true if matches filter
          // determines if volcano should be active on map and interactive
          d.show = true
        });

        // draw volcanoes
        let circles = viewport.selectAll("circle.volcano-circle").data(volcanoes)
          .join("circle")
          .attr("r", 2 / logTransformK)
          .attr("fill", d => eruptionColorScale(d.num_eruptions))
          .attr("opacity", .7)
          .attr("cx", d => d.Position[0])
          .attr("cy", d => d.Position[1])
          .attr("stroke-opacity", 0)
          .attr("stroke", "white")
          .attr("class", "volcano-circle")
          .on("mouseover", mouseOverVolcano)
          .on("mouseout", mouseOutVolcano)

        // extent for sliders
        const elevationExtent = d3.extent(volcanoes, d => d.elevation)
        const eruptionsExtent = d3.extent(volcanoes, d => d.num_eruptions)

        // active filters to show volcanoes
        // elevation and num_eruptions are represented by an extent array
        // volcano type and country are represented by a list of selected
        let filters = {}

        filters["elevation"] = elevationExtent
        filters["num_eruptions"] = eruptionsExtent
        filters["volcano_type"] = []
        filters["country"] = []

        // callback after slider is changed
        // v1, v2 - slider values
        // field - what volcano field slider is representing
        function updateWorldSlider(v1, v2, field) {
          filters[field] = [v1, v2]
          updateWorldMap()
        }

        // returns true of volcano matches current filter
        function volcanoFilter(d) {
          // checks if elevation and num_eruptions in range
          if (d.elevation < filters.elevation[0] || d.elevation > filters.elevation[1]) {
            return false;
          }
          if (d.num_eruptions < filters.num_eruptions[0] || d.num_eruptions > filters.num_eruptions[1]) {
            return false;
          }
          // filter out results when there is an active filter if field does not match
          if (filters.volcano_type.length > 0 && !filters.volcano_type.includes(d.volcano_type)) {
            return false;
          }
          if (filters.country.length > 0 && !filters.country.includes(d.country)) {
            return false;
          }

          // else keep
          return true;
        }

        // called whenever volcano data is filtered
        // sets tag whether or not to show
        function filterData() {
          volcanoes.forEach(v => {
            v.show = volcanoFilter(v)
            return v
          })
        }

        // setup sliders
        makeFilterSlider("Elevation (ft)", elevationExtent[0], elevationExtent[1], "elevation", updateWorldSlider)
        makeFilterSlider("Number of Eruptions", eruptionsExtent[0], eruptionsExtent[1], 'num_eruptions', updateWorldSlider)

        // get all volcano types
        let options = [...new Set(volcanoes.map(d => d.volcano_type))];

        // Add heading and buttons for each volcano type
        let left_panel = d3.select(".left_panel")
        left_panel.append("p").text("Volcano Type").attr("class", "filter_label")

        left_panel.selectAll("button")
          .data(options)
          .join()
          .append("button")
          .text(d => d)
          .attr("class", "volcano_button")
          .on("click", clickVolcanoType)

        // adds/removes volcano type to filter as needed
        // updates style for clicked/unclicked button
        // updates volcanoes
        function clickVolcanoType() {
          volcanoButton = d3.select(this)
          volcanoType = volcanoButton.datum()
          if (filters.volcano_type.includes(volcanoType)) {

            filters.volcano_type = filters.volcano_type.filter(d => d != volcanoType)
            volcanoButton.attr("class", "volcano_button")
          }
          else {
            filters.volcano_type.push(volcanoType)
            volcanoButton.attr("class", "selected-volcano-type")
          }
          updateWorldMap()
        }

        // Add radar title
        left_panel.append("h2").text("Radar")

        let volcanoName = d3.select("#panel").append("h3");
        let volcanoTable = d3.select("#panel").append("table");

        // update data
        // change results
        function updateWorldMap() {

          let data = filterData()

          circles
            .transition(d3.easeCubic).duration(200)
            .attr("r", 2 / logTransformK)
            .attr("fill", d => d.show ? eruptionColorScale(d.num_eruptions) : "#272727")
            .attr("style", d => `pointer-events: ${d.show ? "auto" : "none"}`)
            .attr("opacity", d => d.show ? .7 : .3)
            .attr("stroke-width", 2 / transformK)

        }

        // add hover effect to volcano circle
        // generate table of volcano details
        function mouseOverVolcano() {

          volcano = d3.select(this).datum()
          // if (volcano.show) {
          d3.select(this)
            .transition().duration(200)
            .attr('opacity', 1)
            .attr("stroke-opacity", 1)
          volcanoName.text(volcano.volcano_name)

          dict = {}

          // additional details
          // 1st index is key in volcanoes
          // 2nd index is label
          let keys = [
            ["volcano_type", "Volcano Type"],
            ["country", "Country"],
            ["elevation", "Elevation"],
            ["earliest_eruption_year", "Earliest Eruption Year"],
            ["last_eruption_year", "Last Eruption Year"],
            ["tectonic_settings", "Techtonic Settings"],
            ["num_eruptions", "Number of Eruptions"],
            ["population_within_5_km", "Population Within 5 km"],
            ["population_within_10_km", "Population Within 10 km"],
            ["population_within_30_km", "Population Within 30 km"]]

          keys.forEach(k => {
            dict[k[1]] = volcano[k[0]]
          })

          // reformat earliest/last eruption year
          if (!isNaN(Number(dict.last_eruption_year))) {
            let year = Number(dict.last_eruption_year)
            if (year >= 0) {
              dict.last_eruption_year = +year + ' A.D.'
            }
            else {
              dict.last_eruption_year = -1 * year + ' B.C.'

            }
          }

          if (!isNaN(Number(dict.earliest_eruption_year))) {
            let year = Number(dict.earliest_eruption_year)
            if (year >= 0) {
              dict.earliest_eruption_year = +year + ' A.D.'
            }
            else {
              dict.earliest_eruption_year = -1 * year + ' B.C.'

            }
          }

          dict.Elevation = dict.Elevation + ' ft'

          let kvPairs = Object.entries(dict);

          let rows = volcanoTable.selectAll("tr").data(kvPairs)
            .join(enter => enter.append("tr"),
              update => update.selectAll("td").remove(),
              exit => exit.remove());

          rows.append("td").append("strong").text(d => d[0]);
          rows.append("td").text(d => d[1]);
        }

        // remove right panel with volcano information and remove hover effect on circle
        function mouseOutVolcano() {
          d3.select(this)
            .transition().duration(200)
            .attr("stroke-opacity", 0)
            .attr("opacity", .4)

          volcanoName.text("")

          let rows = volcanoTable.selectAll("tr").data({})
            .join(enter => enter.append("tr"),
              update => update.selectAll("td").remove(),
              exit => exit.remove());

          rows.append("td").append("strong").text(d => d[0]).attr('width', '100px');
          rows.append("td").text(d => d[1]).attr('width', '140px');
        }

        // add zoom effect to map
        var zoom = d3
          .zoom()
          .scaleExtent([1, 10])
          .translateExtent([
            [0, 0],
            [mapWidth, mapHeight],
          ])
          .on("zoom", mapZoomed);
        map.call(zoom);
        map.call(zoom.transform, d3.zoomIdentity);

        // zoom in on map
        function mapZoomed({ transform }) {
          viewport.attr("transform", transform.toString());

          // change outline widths
          viewport
            .select(".country-outline")
            .style("stroke-width", 1 / transform.k);
          map
            .select(".mouseover")
            .style("stroke-width", 1.5 / transform.k);

          // change circle scales
          let log = Math.log(transform.k)
          logTransformK = Math.max(log, 1)
          transformK = transform.k

          d3.selectAll("circle.volcano-circle").attr("stroke-width", 2 / transformK).attr('r', 2 / logTransformK)

          viewport.select(".outline").style("stroke-width", 1 / transformK);
        }

        // load country data for radar
        let groupedCountryData = await d3.csv(".././static/grouped_volcanoes.csv");

        //convert to number 
        groupedCountryData.forEach((d, i) => {
          d['elevation'] = Number(d['elevation'])
          d['num_eruptions'] = Number(d['num_eruptions'])
          d['num_volcanoes'] = Number(d['num_volcanoes'])
          d['population_within_5_km'] = Number(d['population_within_5_km'])
          d['eruption_length'] = Number(d['eruption_length'])
          d['vei'] = Number(d['vei'])
        })


        // create radar

        let width = 250;
        let height = 250;

        let radar = left_panel.append("svg")
          .attr("width", width)
          .attr("height", height)
          .attr("id", "radar")

        let radialScale = d3.scaleLinear()
          .domain([0, 10])
          .range([0, 100]);

        let ticks = [2, 4, 6, 8, 10];

        function angleToCoordinate(angle, value) {
          let x = Math.cos(angle) * radialScale(value);
          let y = Math.sin(angle) * radialScale(value);
          return { "x": width / 2 + x, "y": height / 2 - y };
        }

        features = ["eruption_length", "elevation", "population_within_5_km",
          "vei", "num_volcanoes", "num_eruptions"]

        let featureData = features.map((f, i) => {
          let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
          return {
            "name": f,
            "angle": angle,
            "line_coord": angleToCoordinate(angle, 10),
            "label_coord": angleToCoordinate(angle, 10.5)
          };
        });

        // draw axis line
        radar.selectAll("line")
          .data(featureData)
          .join("line")
          .attr("x1", width / 2)
          .attr("y1", height / 2)
          .attr("x2", d => d.line_coord.x)
          .attr("y2", d => d.line_coord.y)
          .attr("stroke", "white");


        let labels = ["eruption length", "elevation", "population",
          "VEI", "# volcanoes", "# eruptions"]

        let labelR = radialScale(10) + 15;
        let defs = radar.append("defs");


        let topPath = [
          "M", width / 2 - labelR, height / 2,
          "A", labelR + .2, labelR, 0, 0, 1, width / 2 + labelR, height / 2
        ].join(" ");

        let bottomPath = [
          "M", width / 2 - labelR, height / 2,
          "A", labelR - .2, labelR, 0, 0, 0, width / 2 + labelR, height / 2
        ].join(" ");

        let pathsData = [
          { id: "topPath", d: topPath },
          { id: "bottomPath", d: bottomPath }
        ];

        let topLabels = labels.slice(0, 3);
        let bottomLabels = labels.slice(3, 6).reverse();

        defs.selectAll("path.def")
          .data(pathsData, d => d.id)
          .join(
            e => e.append("path")
              .attr("id", d => d.id)
              .attr("d", d => d.d)
          );

        //top three labels
        radar.selectAll(".axislabel")
          .data(topLabels)
          .join(
            enter => enter.append("text")
              .append("textPath")
              .attr("href", "#topPath")
              .style("text-anchor", "start")
              .attr("startOffset", (d, i) => {
                if (d === "elevation") {
                  return `${(i / topLabels.length) * 100 + 7}%`
                }
                else return `${(i / topLabels.length) * 100 + 2}%`;
              })
              .text(d => d)
              .style("fill", "white")
          );

        //bottom three labels
        radar.selectAll(".axislabel")
          .data(bottomLabels)
          .join(
            enter => enter.append("text")
              .append("textPath")
              .attr("href", "#bottomPath")
              .style("text-anchor", "start")
              .attr("startOffset", (d, i) => {
                if (d === "VEI") {
                  return `${(i / bottomLabels.length) * 100 + 13}%`
                }
                else return `${(i / bottomLabels.length) * 100 + 5}%`;
              })
              .text(d => d)
              .style("fill", "white")
          );

        //creating circles for tick values
        radar.selectAll("circle.radar-circles")
          .data(ticks)
          .join("circle")
          .attr("cx", width / 2)
          .attr("cy", height / 2)
          .attr("fill", "none")
          .attr("stroke", "white")
          .attr("stroke-width", 2)
          .attr("opacity", .5)
          .attr("class", "radar-circles")
          .attr("r", d => radialScale(d));

        // Create a linear scale for each feature
        let scales = {}
        features.forEach(f => scales[f] = d3.scaleLinear().range([0, 9]))

        //update radar graph function 
        function updateSpiderGraph() {

          let countryData = groupedCountryData.filter(d => filters.country.includes(d.country));

          // order by country
          countryData = countryData.sort((c1, c2) => {
            console.log(filters.country.indexOf(c1.country))
            console.log(filters.country.indexOf(c2.country))
            return filters.country.indexOf(c1.country) - filters.country.indexOf(c2.country)
          })
          console.log(countryData)

          // Update domains of linear scales
          features.forEach(f => scales[f].domain([0, d3.max(countryData, d => d[f])]))

          let scaledData = countryData.map(d => {
            return {
              "eruption_length": scales.eruption_length(d.eruption_length),
              "elevation": scales.elevation(d.elevation),
              "population_within_5_km": scales.population_within_5_km(d.population_within_5_km),
              "vei": scales.vei(d.vei),
              "num_eruptions": scales.num_eruptions(d.num_eruptions),
              "num_volcanoes": scales.num_volcanoes(d.num_volcanoes)
            };
          });

          let line = d3.line()
            .x(d => d.x)
            .y(d => d.y);
          let colors = ["red", "yellow", "darkorange"];

          function getPathCoordinates(data_point) {
            let coordinates = [];
            for (var i = 0; i < features.length; i++) {
              let ft_name = features[i];
              let angle = (Math.PI / 2) + (2 * Math.PI * i / features.length);
              coordinates.push(angleToCoordinate(angle, data_point[ft_name]));
            }
            return coordinates;
          }

          const polys = radar.selectAll("path.poly")
            .data(scaledData);

          polys
            .join(
              enter => enter.append("path")
                .datum(d => getPathCoordinates(d))
                .attr('class', 'poly')
                .attr("d", line)
                .attr("stroke-width", 3)
                .attr("stroke", (_, i) => colors[i])
                .attr("fill", (_, i) => colors[i])
                .attr("stroke-opacity", 1)
                .attr("opacity", 0.5)
                .on("mouseover", () => { console.log(d3.select(this).datum()) }),
              update => update
                .datum(d => getPathCoordinates(d))
                .transition()
                .duration(750)
                .attr("d", line)
                .attr("stroke-width", 3)
                .attr("stroke", (_, i) => colors[i])
                .attr("fill", (_, i) => colors[i])
                .attr("stroke-opacity", 1)
                .attr("opacity", 0.5),
            )
        };
      }

      drawMap();

      // creates slider
      function makeFilterSlider(title, v1, v2, field, updateGraph) {

        let sliderExtent = [v1, v2]
        let width = 200

        // add slider title
        d3.select(".left_panel").append("p").text(title).attr("class", "filter_label")


        // svg container
        let container = d3.select(".left_panel").append("svg")
          .attr("id", `slider-${field}`)
          .attr('width', width + 30)
          .attr('height', 50);

        // value to pixel scale
        let xScale = d3.scaleLinear()
          .domain([v1, v2])
          .range([0, width])
          .clamp(true);

        // extreme values in pixels
        let xMin = xScale(v1)
        let xMax = xScale(v2)

        // slider g tag
        let slider = container.append("g")
          .attr("class", "slider")
          .attr("transform", "translate(5,20)");

        // slider background (non-selected)
        slider.append("line")
          .attr("class", "track")
          .attr("x1", 10 + xScale.range()[0])
          .attr("x2", 10 + xScale.range()[1])

        // selected section
        slider.append("line")
          .attr("class", "selected")
          .attr("x1", 10 + xScale(sliderExtent[0]))
          .attr("x2", 10 + xScale(sliderExtent[1]))

        // create ticks
        slider.insert("g", ".track-overlay")
          .attr("class", "slider-ticks")
          .attr("transform", "translate(10,24)")
          .selectAll("text")
          .data(xScale.ticks(5))
          .enter().append("text")
          .attr("x", xScale)
          .attr("text-anchor", "middle")
          .style("font-weight", "bold")
          .style("fill", "white")
          .text(d => d);

        // create drag knobs
        slider.selectAll("rect")
          .data([0, 1])
          .enter().append("rect", ".track-overlay")
          .attr("class", "knob")
          .attr("y", -8)
          .attr("x", d => xScale(sliderExtent[d]))
          .attr("rx", 3)
          .attr("height", 16)
          .attr("width", 20)
          .call(
            d3.drag()
              .on("start", startDrag)
              .on("drag", drag)
              .on("end", endDrag)
          );

        function startDrag() {
          d3.select(this).raise().classed("active", true);
        }

        // change position of knob
        function drag(d) {
          let x1 = d.x;
          if (x1 > xMax) {
            x1 = xMax
          } else if (x1 < xMin) {
            x1 = xMin
          }
          d3.select(this).attr("x", x1);
          let x2 = xScale(sliderExtent[d.subject == 0 ? 1 : 0])
          selectedSection
            .attr("x1", 10 + x1)
            .attr("x2", 10 + x2)
        }

        // change knob positions and update world
        function endDrag(d) {
          let v = Math.round(xScale.invert(d.x))
          let elem = d3.select(this)
          sliderExtent[d.subject] = v
          let v1 = Math.min(sliderExtent[0], sliderExtent[1]),
            v2 = Math.max(sliderExtent[0], sliderExtent[1]);
          elem.classed("active", false)
            .attr("x", xScale(v));
          selectedSection
            .attr("x1", 10 + xScale(v1))
            .attr("x2", 10 + xScale(v2))
          updateGraph(v1, v2, field);
        }
      }

    </script>

  </div>
</body>

</html>